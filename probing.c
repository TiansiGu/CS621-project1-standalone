#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <netdb.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <fcntl.h>
#include <errno.h>
#include <pthread.h>

#include "standalone.h"
#include "payload_generator.h"

#define RECV_BUFF_SIZE 4096
#define IPH_ID 54321 //IP header identifier for SYN packets
#define SYN_TTL 64   //TTL for SYN packets
#define TCP_WIN_SIZE 65535 //TCP window size for the SYN packets

/** the time that the application would spend to listen for the RST packet for the 
head/tail SYN packets until we consider them lost or never generated by the server */
#define CUTOFF_TIME 60 

struct timespec t_first_SYN_sent = {0};
pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
int is_server_ready = 0;

struct tcp_pseudo_header {
    u_int32_t src_address;
    u_int32_t dst_address;
    u_int8_t placeholder;
    u_int8_t protocol;
    u_int16_t tcp_length;
	struct tcphdr tcp;
};

/* this function generates header checksums */
unsigned short csum(unsigned short *buf, int nwords) {
  unsigned long sum;
  for (sum = 0; nwords > 0; nwords--)
    sum += *buf++;
  sum = (sum >> 16) + (sum & 0xffff);
  sum += (sum >> 16);
  return ~sum;
}

int populate_ip_header(struct ip *iphr, struct configurations *configs, int protocol, int data_size) {
	iphr->ip_v = 4; //ipv4
	iphr->ip_hl = 5; //set ip header size to be the minimum: 5*4 = 20 bytes
	iphr->ip_tos = 0; //type of service
	iphr->ip_len = iphr->ip_hl * 4 + data_size; //no payload
	iphr->ip_id = htons(IPH_ID); //all datagrams between src and dst of a given protocol must have unique IPv4 ID over a period of MDL
	iphr->ip_off = htons(IP_DF);  //set don't fragment bit
	iphr->ip_ttl = SYN_TTL; //TTL is a single byte, no need to convert endian
	iphr->ip_p = protocol; //tcp is 6, udp is 17
	iphr->ip_sum = 0; //set to 0 before computing the actual checksum later

    // unsigned long src_addr;
    // if (get_host_addr(&src_addr) == -1) return -1; /* get host real ip addr*/
	iphr->ip_src.s_addr = inet_addr(configs->client_ip_addr); /* addr in hostent struct are already in network byte order */
	iphr->ip_dst.s_addr = inet_addr(configs->server_ip_addr); /* inet_addr returns value in network byte order */
	
	// Calculate and set the IP header checksum
    iphr->ip_sum = csum((unsigned short *)iphr, sizeof(struct ip) >> 1);
	
	return 0;
}

void populate_tcp_header(struct tcphdr *tcphr, struct ip *iphr, uint16_t src_port, uint16_t dst_port) {
	tcphr->th_sport = htons(src_port);
  	tcphr->th_dport = htons(dst_port);
	tcphr->th_seq = random(); /* start from random sequence number */
	tcphr->th_ack = 0; /* the ack sequence is 0 in the 1st packet */
	tcphr->th_x2 = 0;  /* reserved field */
	tcphr->th_off = 5; /* set the tcp hdr length to be minimum value 20 bytes, as no options */
	tcphr->th_flags = TH_SYN; /* SYN packet */
	tcphr->th_win = htons(TCP_WIN_SIZE); /* max allowed window size, doesn't matter as receiver only sends RST back */
	tcphr->th_sum = 0;
	tcphr->th_urp = 0; /* urgent pointer is not used for this app */

	// Use tcp pseudo header to calculate checksum
	struct tcp_pseudo_header psh;
    // Fill in tcp pseudo header
    psh.src_address = iphr->ip_src.s_addr;  // Source IP address
    psh.dst_address = iphr->ip_dst.s_addr;    // Destination IP address
    psh.placeholder = 0;                        // Reserved, always 0
    psh.protocol = IPPROTO_TCP;                 // Protocol number (TCP = 6)
    psh.tcp_length = htons(sizeof(struct tcphdr)); 
	memcpy(&(psh.tcp), tcphr, sizeof(struct tcphdr));
    
    /* Calculate the checksum and fill it in */
    tcphr->th_sum = csum((unsigned short*)&psh, sizeof(struct tcp_pseudo_header) >> 1);
}

int send_SYN(int sock_syn, struct configurations *configs, uint16_t server_port) {
	struct ip iphr;
	int res = populate_ip_header(&iphr, configs, IPPROTO_TCP, sizeof(struct tcphdr)); //no payload, data_size is only tcp header size
	if (res == -1) {
		printf("Create ip header failed for tcp SYN \n");
		return -1;
	}

	struct tcphdr tcphr;
	populate_tcp_header(&tcphr, &iphr, configs->client_port_SYN, server_port);
	
	//tcphr.th_sum = tcp_checksum(&tcphr, &iphr, 0); // set checksum in tcp header

	char* buffer = malloc(iphr.ip_len); // initialize buffer for sending
	memcpy(buffer, &iphr, iphr.ip_hl * 4); // copy ip header
	char *tcp_ptr = buffer + iphr.ip_hl * 4;
	memcpy(tcp_ptr, &tcphr, tcphr.th_off * 4); // copy tcp header

	// Set IP_HDRINCL option
	int one = 1;
    res = setsockopt(sock_syn, IPPROTO_IP, IP_HDRINCL, &one, sizeof(one));
    if (res == -1) {
		perror("Warning: Cannot set HDRINCL!");
		return -1;
	}

	// create sin used in sendto func
	struct sockaddr_in sin;
	sin.sin_family = AF_INET;
	sin.sin_addr.s_addr = inet_addr(configs->server_ip_addr);
	sin.sin_port = htons(server_port);

	// send SYN packet
	res = sendto(sock_syn, buffer, iphr.ip_len, 0, 
		(struct sockaddr *) &sin, sizeof(sin));
	if (res == -1) {
		perror("Failed to send SYN packet");
		return -1;
	}
    free(buffer);
	return 0;
}

void bind_port(int fd, int port, struct sockaddr_in *addr) {
	addr->sin_family = AF_INET;
    addr->sin_addr.s_addr = INADDR_ANY;
    addr->sin_port = htons(port);

	if (bind(fd, (struct sockaddr*) addr, sizeof(struct sockaddr_in)) == -1) {
		perror("Failed to bind socket");
		close(fd);
		exit(EXIT_FAILURE);
	}
}

void set_ttl(int fd, int ttl) {
	int result = setsockopt(fd, IPPROTO_IP, IP_TTL, &ttl, sizeof(ttl));
	if (result == -1) {
		perror("Failed to set ttl");
		close(fd);
		exit(EXIT_FAILURE);
	}
}

int send_UDP_train(int sock_udp, struct configurations *configs, 
	struct sockaddr_in *server_sin, int high) {
	// Generate udp payload
	unsigned char *payload = generate_payload(configs->l, high);

	// Send packet train
	int count;
	for (int i = 0; i < configs->n; i++) {
		fill_packet_id(payload, i);
		count = sendto(sock_udp, payload, configs->l, 0, (struct sockaddr *) server_sin, sizeof(struct sockaddr_in));
		if (count == -1) {
			perror("Failed to send UDP packet");
			free(payload);
			return -1;
		}
	}
	free(payload); //free allocated resource
	return 0;
}

void send_detect_packets(void *arg) {
	struct configurations *configs = (struct configurations *) arg;

	int sock_syn = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
	if (sock_syn == -1) {
	    perror("SYN raw socket creation failed");
	    exit(EXIT_FAILURE);
	}
	
	int sock_udp = socket(AF_INET, SOCK_DGRAM, 0);
	if (sock_udp == -1) {
		perror("UDP socket creation failed");
		exit(EXIT_FAILURE);
	}

	// Create client and server addr for sending udp train
	struct sockaddr_in client_sin, server_sin;
	memset(&client_sin, 0, sizeof(client_sin));
	memset(&server_sin, 0, sizeof(server_sin));

	in_addr_t server_addr = inet_addr(configs->server_ip_addr);

    server_sin.sin_family = AF_INET; /* address from Internet, IP address specifically */
	server_sin.sin_addr.s_addr = server_addr; /* already in network order */
	server_sin.sin_port = htons(configs->udp_dst_port); /* convert to network order */

	// Specify the port client uses to connect to server
	bind_port(sock_udp, configs->udp_src_port, &client_sin);
	// Set ttl from configs
	set_ttl(sock_udp, configs->ttl);

	// Send head SYN
	int result = send_SYN(sock_syn, configs, configs->server_port_head_SYN);
	if (result == -1) {
		printf("Failed to send head SYN packet \n");
		close(sock_syn);
		close(sock_udp);
	}
	pthread_mutex_lock(&lock); 
	clock_gettime(CLOCK_MONOTONIC, &t_first_SYN_sent); //Start timer as soon as the first SYN is sent
	pthread_mutex_unlock(&lock);

	// Send UDP trains
	result = send_UDP_train(sock_udp, configs, &server_sin, 0);
	if (result == -1) {
		close(sock_syn);
		close(sock_udp);
	}
	// Send tail SYN 
	result = send_SYN(sock_syn, configs, configs->server_port_tail_SYN);
	if (result == -1) {
		close(sock_syn);
		close(sock_udp);
	}

	sleep(configs->gamma);

	// Send head SYN
	result = send_SYN(sock_syn, configs, configs->server_port_head_SYN);
	if (result == -1) {
		close(sock_syn);
		close(sock_udp);
	}
	// Send UDP trains
	result = send_UDP_train(sock_udp, configs, &server_sin, 1);
	if (result == -1) {
		close(sock_syn);
		close(sock_udp);
	}
	// Send tail SYN 
	result = send_SYN(sock_syn, configs, configs->server_port_tail_SYN);
	if (result == -1) {
		close(sock_syn);
		close(sock_udp);
	}

	close(sock_syn);
	close(sock_udp);
	printf("Sender thread done \n");
}

void *start_send(void *arg) {
	pthread_mutex_lock(&lock);
	while (!is_server_ready) {
		pthread_cond_wait(&cond, &lock);
	}
	pthread_mutex_unlock(&lock);
	
	printf("receiver ready, start sending detect packets now... \n");
	send_detect_packets(arg);
	return NULL;
}

void set_nonblocking(int fd) {
	int flags = fcntl(fd, F_GETFL, 0);
	if (flags == -1) {
        perror("Failed to get file status flags by fcntl F_GETFL");
        exit(EXIT_FAILURE);
    }
	int result = fcntl(fd, F_SETFL, flags | O_NONBLOCK);
	if (result == -1) {
        perror("Failed to set O_NONBLOCK flag");
		close(fd);
        exit(EXIT_FAILURE);
    }
}


/** Parse packet received from raw socket and identify if this packet is a RST packe.
If it is not a related RST packet, return -1. If it is a RST packet sent from head SYN 
port, return 0; If it is a RST packet sent from tail SYN port, return 1. */
int parse_recv_packet(unsigned char *buf, struct configurations *configs) {
	struct ip *iph = (struct ip *) buf;
	if (iph->ip_v != 4) {
		printf("ip version unmatch: %d\n", iph->ip_v);
		return -1; //only keep ipv4 
	}
	if (iph->ip_src.s_addr != inet_addr(configs->server_ip_addr)) {
		printf("ip addr unmatch\n");
		return -1;
	} //not from the detecting server we sent SYN to

	struct tcphdr *tcph = (struct tcphdr *) (buf + iph->ip_hl * 4); 
	if (tcph->th_flags & TH_RST == 0) {
		printf("RST bit not set \n");
		return -1;
	} //RST bit not set packet
	
	uint16_t src_port = ntohs(tcph->th_sport);
	if (src_port == configs->server_port_head_SYN) {
		return 0;
	} else if (src_port == configs->server_port_tail_SYN) {
		return 1;
	} else {
		printf("th sport unmatch: %u \n", src_port);
		return -1;
	}
}

int is_first_SYN_sent() {
	pthread_mutex_lock(&lock); //lock before read
	int res = !(t_first_SYN_sent.tv_sec == 0 && t_first_SYN_sent.tv_nsec == 0);
	pthread_mutex_unlock(&lock); //unlock after read
	return res;
}

void wakeup_sender() {
	pthread_mutex_lock(&lock);
	is_server_ready = 1; 
	pthread_cond_signal(&cond);
	pthread_mutex_unlock(&lock);
}

void *start_recv(void *arg) {
	//sleep(5); //to be deleted
	struct configurations *configs = (struct configurations *) arg;

	int sock = socket(AF_INET, SOCK_RAW, IPPROTO_TCP);
	if (sock == -1) {
	    perror("RST listener raw socket creation failed");
	    exit(EXIT_FAILURE);
	}

	// Set non-blocking
	set_nonblocking(sock);

	unsigned char buf[RECV_BUFF_SIZE];

	int count;
	struct timespec t_l1, t_ln, t_h1, t_hn, t_curr;
	int head_c = 0, tail_c = 0;
	int flag = 0; //represent if sender has been started
	while (1) {
		// sender addr is sent in to filter the received packets
        count = recvfrom(sock, buf, RECV_BUFF_SIZE, 0, NULL, NULL);
        if (count == -1) {
			if (errno == EAGAIN || errno == EWOULDBLOCK) {
				clock_gettime(CLOCK_MONOTONIC, &t_curr);
				if (!flag) {
					flag = 1;
					wakeup_sender();
				}
				if (is_first_SYN_sent() && t_curr.tv_sec - t_first_SYN_sent.tv_sec > CUTOFF_TIME) {
					printf("Failed to detect due to insufficient information.\n");
					break;
				} else {
					continue; // No data available (non-blocking)
				}
			} else {
				perror("Recvfrom failed");
            	close(sock);
				exit(EXIT_FAILURE);
			}  
        }

		// parse received buffer and filtered out packets 
		int result = parse_recv_packet(buf, configs);
		printf("get a packet, result %d\n", result);
		if (result == 0) {
			if (head_c == 0) clock_gettime(CLOCK_MONOTONIC, &t_l1);
			else clock_gettime(CLOCK_MONOTONIC, &t_ln);
			head_c++;
		} else if (result == 1) {
			if (tail_c == 0) clock_gettime(CLOCK_MONOTONIC, &t_h1);
			else clock_gettime(CLOCK_MONOTONIC, &t_hn);
			tail_c++;
		} else {
			continue;
		}

		if (head_c == 2 && tail_c == 2) {
			printf("Received RST packets done \n");
			break;
		}
	}

	if (head_c == 2 && tail_c == 2) {
		long t_l = (t_ln.tv_sec - t_l1.tv_sec) * 1000L + (t_ln.tv_nsec - t_l1.tv_nsec) / 1000000L;
		long t_h = (t_hn.tv_sec - t_h1.tv_sec) * 1000L + (t_hn.tv_nsec - t_h1.tv_nsec) / 1000000L;
		printf("Time difference %ld\n", t_h - t_l);
		if (t_h - t_l > configs->tau) {
			printf("Compression detected!\n");
		} else {
			printf("No compression was detected.\n");
		}
	}

	close(sock);
	printf("Receiver thread done \n");
	return NULL;
}

void probe(struct configurations *configs) {
	pthread_t sender_thr, listener_thr;
	// create sender thread
	int sender_thr_result = pthread_create(&sender_thr, NULL, start_send, configs);
	if (sender_thr_result != 0) {
		perror("Error occurred when creating sender thread");
		exit(EXIT_FAILURE);
	}

	// create listener thread
	int listener_thr_result = pthread_create(&listener_thr, NULL, start_recv, configs);
	if (listener_thr_result != 0) {
		perror("Error occurred when creating listener thread");
		exit(EXIT_FAILURE);
	}

	// Wait for both of the threads to finish
	pthread_join(sender_thr, NULL);
	pthread_join(listener_thr, NULL);

	printf("Detection completed! \n");
}
